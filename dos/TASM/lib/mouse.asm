;---------------------------------------        
SetCursor proc 
	; Инициализация мыши
	mov ax, 0h
	int 33h
	;show mouse
	mov ax, 1h
	int 33h
	; получить положением мыши и статус
	; mov ax, 3h
	; int 33h
	ret
SetCursor endp 

       
;---------------------------------------              
; Полуить положение курсора   
; возврат : BX : бит 0 = 0 : нажата левая кнопка мыши.
;                      = 1 : отпущена левая кнопка мыши.
;            :   бит 1 = 0 : нажата правая кнопка мыши..
;                      = 1 : отпущена правая кнопка мыши.
;         CX = x.
;         DX = y.
GetMouseState proc 
	mov  ax, 3       ;Эта функция позволяет определить где пользователь кликнул мышкой. Определить состояние мыши
	int  33h
	ret
GetMouseState endp 



;------------------------------------------
; Конверитируем число в троку 
; Алгоритм : разбить число на цифры, сохранить из в стэк, затем перевернуть их 
; чтобы записать в одну строку.
; параметры : AX = число которое конвертируем.
;             SI = указатель на строку, в которую запишем конвертируемое число, т.е. в эту строку мы запишем символы бывшего числа.
; регистры которые изменятся : AX, BX, CX, DX, SI.


num2str proc ; то число которое мы будем преобразовывать в строку уже записано в ax тут мы будем делить ax на bx
	mov  bx, 10  ; чтобы преобразовать число в строку мы должны разобрать его по числам, для это го будем число делить на 10
	mov  cx, 0   ; счётчик чисел в числе пример: 635 6,3,5 = 3 цифры в числе 635
_cycle1:       
	mov  dx, 0   ; так как результат запишется по адресу DX:AX то мы обнуляем dx
	div  bx      ; DX:AX / 10 = AX:целая часть DX:остаток. 
	; В остатке как раз и будет одна цифра из числа 635: 635%10=5 635/10=63 -> в dx=5, ax=63; 
	push dx      ; сохраняем цифру 5 в стэк чтобы потом записать его в строку.
	inc  cx      ; увеличиваем счётчик в cx. Этот счётчик нужен именно для цикла loop.
	cmp  ax, 0   ; если регист ax
	jne  _cycle1  ; не равен нули цикл продолжается

; здесь мы берем цифры из стэка которые записали выше
_cycle2:  ; это цикл работает пока cx не станет равен нулю. Сам цикл loop подразумевает что cx с каждой итерацией уменьшается
	pop  dx ; достайм из стэка последнюю цифру которую туда записывали
	add  dl, 48  ; это такой способ конвертировать цифру в символ: 2 -> '2'
	mov  [ si ], dl ; как вы помните перед вызовом этой функции в si мы поместили адрес первого символа строки. 
	; Теперь на этот адрес помещаем символ
	inc  si ; смещаемя на второй адрес строки
	loop _cycle2  ; пока cx не станет нулю

	ret ; возвращаем управление в точку вызова
num2str endp    


checkColorPixel proc
	push bp
	mov bp, sp

	mov ah, 0Dh ; функция получения цвета по координатам
	mov cx, [x_mouse] 
	mov dx, [y_mouse]
	int 10H ; AL = цвет
	cmp al, byte ptr randomColor ; такой приём позволяет сравнить 8бит регистр с 16 битной переменной, т.е. мы как бы преобразуем randomColor в 8 бит
	je noblack
	jmp next
noblack:
	mov isNew, 1
	jmp next
next:
	mov sp, bp
	pop bp
	ret

checkColorPixel endp


;